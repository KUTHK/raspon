# ポーリング

冒頭: 割り込みを使わずに入力処理を行う最もシンプルな形を理解する。

## 簡単（初心者向け）

- 一定間隔で入力レジスタを読み直し、状態変化を検出して処理する。

## スイッチ入力例

```asm
  .include "src/include/common.h"
_start:
  ldr r0, =GPIO_BASE
  ldr r1, [r0, #GPLEV0]
  tst r1, #(1 << SW1_PORT)
  bne handle_pressed
```

## 割り込みとの違い

- 割り込み: 変化時にCPUへ通知。
- ポーリング: CPUが自分で見に行く。条件に当てはまれば実行。

まとめ: 「読む→判定→処理」を繰り返すだけ。タイマで間隔を作ると安定する。

## 普通（上級者向け）


### エッジ検出と状態機械

- 直前状態 prev と現在状態 cur を保持し、(prev=0, cur=1) を立上り、(prev=1, cur=0) を立下りとする。
- 長押し・オートリピートは押下継続時間のしきい値を持つ簡単な状態機械で実装。

### サンプリング間隔とCPU負荷

- 入力の応答性（レイテンシ）≒ サンプリング周期。10ms 周期なら最悪 10ms の遅れ。
- 周期を短くすると応答性は上がるがCPU時間を消費。処理ブロックの実測時間に対して十分余裕を持つ設定に。

### タイマ利用

- busy-wait ではなく、ハードウェアタイマで一定間隔を生成し、そのタイムスタンプ基準で次回ポーリングを実施すると安定。
- 処理時間を含めた周期設計（周期=スリープ+処理）に注意。

まとめ: ポーリングは「周期」「デバウンス」「エッジ／長押し検出」を揃えて設計。必要ならタイマと状態機械で堅牢にする。
