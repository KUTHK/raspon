# ポーリング

冒頭: 割り込みを使わずに入力処理を行う最もシンプルな形である。

## 簡単（初心者向け）

- 一定間隔で入力レジスタを読み直し、状態変化を検出して処理する方法である。

## スイッチ入力例（ARMアセンブリ）

```armasm
  .include "src/include/common.h"
_start:
  ldr r0, =GPIO_BASE      // GPIOベースアドレスをr0にロードする
polling_loop:
  ldr r1, [r0, #GPLEV0]   // 入力レベルレジスタをr1にロードする
  tst r1, #(1 << SW1_PORT) // SW1_PORTビットをテストする
  bne handle_pressed      // 押下時はhandle_pressedへ分岐する
  b pollin_loop           // ループする
handle_pressed:
  // 押下時の処理を書く
  b polling_loop
```

## 割り込みとの違い

- 割り込みは、入力変化時にCPUへ通知する方式である。
- ポーリングは、CPUが自ら状態を監視し、条件に合致すれば処理を実行する方式である。

まとめ: 「読む→判定→処理」を繰り返すだけである。タイマで間隔を作ると安定する。

## 普通（上級者向け）

- ポーリングは、CPUが定期的にハードウェアの状態を監視し、必要な処理を行う手法である。
- 割り込み方式と比べて実装が単純でデバッグしやすい反面、CPUリソースを多く消費しがちである。
- タイマや遅延ループを使って監視間隔を調整することで、CPU負荷と応答性のバランスを取ることができる。
- 複数の入力やデバイスを扱う場合、各入力を順番にチェックする「ラウンドロビン方式」なども利用される。
- 状態変化の検出には「前回値」と「現在値」を比較することで、エッジ（立ち上がり/立ち下がり）を検出できる。

### ポーリングのメリット・デメリット

| メリット             | デメリット                |
|----------------------|--------------------------|
| 実装が簡単である     | 応答性が低くなりやすい   |
| デバッグしやすい     | CPUリソースを消費する    |
| タイミング制御が容易 | 多数の入力で効率低下     |

### 状態変化検出の例

```armasm
  ldr r0, =GPIO_BASE
  ldr r2, [r0, #GPLEV0]   // 前回値をr2に保存する
polling_loop:
  ldr r1, [r0, #GPLEV0]   // 現在値をr1にロードする
  cmp r1, r2
  beq no_change
  // 状態変化時の処理を書く
  mov r2, r1              // 前回値を更新する
no_change:
  // 適切な待機処理を挿入する
  b polling_loop
```