# CPU の基本

冒頭: CPUが「機械語」を解釈してレジスタとメモリを操作し、メモリマップI/Oを通じて外部とやり取りする流れを掴む。

## 簡単（初心者向け）

- 機械語: CPUが理解するのはビット列（機械語）。アセンブリはそれを人が読める形にした表記。
- レジスタ: 計算やアドレス保持のための超高速な小領域。ARMでは r0〜r15 とフラグ（NZCVなど）を持つ。
- メモリ: 命令やデータが置かれる大きな領域。
- メモリマップI/O: 周辺装置のレジスタが「メモリ上の特定アドレス」に見える仕組み。普通の読み書きと同じ手順で制御できる。

まとめ: 機械語で命令が動き、レジスタとメモリを操作し、I/Oはメモリアドレス経由で触る——この3点を押さえれば土台はOK。

## 普通（上級者向け）

### 機械語（命令の表現と実行）

- フェッチ→デコード→実行のパイプラインで命令が流れる。分岐やメモリアクセスはパイプラインに影響を与える（遅延や順序）。
- PC（プログラムカウンタ）を一般レジスタとして読むと、パイプラインの先読み分が加算された値（概念的に「現在の命令アドレス+8」）が得られる性質を持つ。

### レジスタ（役割と呼出規約）

- 汎用レジスタ: r0〜r12。r13、r14、r15はそれぞれ
- 特殊レジスタ: r13=sp（スタックポインタ）, r14=lr（リンクレジスタ/戻り先）, r15=pc（プログラムカウンタ）。
- フラグ: CPSR の NZCV（負・ゼロ・キャリー・オーバーフロー）を多くの演算が更新し、条件実行や分岐の判定に使われる。

### メモリ（配置・整列・エンディアン）

- 実行開始位置: 本プロジェクトでは .init セクションを 0x8000 に配置し、そこから実行開始する前提（リンク時に配置）。
- 整列: 32bitアクセスは4バイト境界に整列させるのが基本。未整列アクセスは性能低下や例外の原因。
- エンディアン: Raspberry Pi 3 はリトルエンディアン。すなわち、32bit値をメモリに格納する際、最下位バイトが最も小さいアドレスに置かれる（例: 0x12345678 → 78 56 34 12 の順で格納）。

### メモリマップI/O（アドレス空間と順序性）

- 周辺装置の制御レジスタはメモリアドレスに割り当てられる。
- 例えば Raspberry Pi 3 では、GPIO（汎用入出力）の制御レジスタは 0x3F200000 から始まるアドレスに割り当てられている。
- CPU から見ると、これらは通常のメモリと同じようにアクセスできるが、実際にはハードウェアの状態を直接制御・取得している。

まとめ: 機械語の実行特性（パイプライン・PC）、レジスタの役割と規約、メモリの配置/整列/エンディアン、メモリマップI/Oのアドレスと順序性を理解すれば、コードがどのようにハードを動かすかが見通せる。
