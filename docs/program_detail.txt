寺内俊輔
1	main.s
1.1	_start
1.1.1	ループ前に初期化を行いメインループの中でcheckとHK_displayを呼び出す
1.2	check
1.2.1	main_statusの値を参照し適切な画面を呼び出すサブルーチン
1.3	start_game
1.3.1	スタート画面データの書き込みとボタンが押された場合main_statusの値を書き換えるサブルーチン
1.4	play_game
1.4.1	プレイ中のゲーム画面データの書き込みとボタンが押された場合main_statusの値を書き換えるサブルーチン
1.5	stop_game
1.5.1	スコア表示画面データの書き込みとボタンが押された場合main_statusの値を書き換えるサブルーチン
1.6	end_game
1.6.1	リザルト画面データの書き込みとボタンが押された場合main_statusの値を書き換えるサブルーチン
1.7	all_init
1.7.1	初期化とボタン入力受付クールタイムを設定するサブルーチン
1.8	game_restart
1.8.1	一点入るごとにリセットが必要なものの初期化
1.9	score_cool_time
1.9.1	ボタン入力のクールタイムを設定するためのサブルーチン
1.10	check_end
1.10.1	HK_winnerを参照して勝者がいる場合main_statusを書き換えるサブルーチン
2	switch.s
2.1	TS_switch
2.1.1	TS_cool_timeの値と現在時刻を比較してボタンの入力を受け取るか判断するサブルーチン、スイッチ系のサブルーチンは主にここで呼び出す
2.2	sw_p1
2.2.1	ボタン1と2が押されたかどうかを判定してr4に対応するビットを立てるサブルーチン
2.3	sw_p2
2.3.1	ボタン3と4が押されたかどうかを判定してr4に対応するビットを立てるサブルーチン
2.4	sw_check
2.4.1	ボタンの入力が行われた瞬間だけTS_switch_outの対応するbitに1を立てるサブルーチン
2.5	TS_switch_init
2.5.1	スイッチの初期化を行うサブルーチン
3	player_board
3.1	TS_player_board
3.1.1	時刻を判定してタスクを行うかどうか判定する処理
3.2	task
3.2.1	ボタンの入力に応じてplayer1とplayer2を横移動させるサブルーチン,TS_player1_borad_drawとTS_player2_borad_drawとsaveのサブルーチンも呼び出す
3.3	task_target_time_update
3.3.1	TS_task_target_time_updateの更新を行うサブルーチン
3.4	save
3.4.1	それぞれのプレイヤーの最後に動いた時刻と動いた方向を保存するサブルーチン
3.5	TS_player_board_init
3.5.1	プレイヤー系の情報の初期化を行うサブルーチン
4	player_board_draw
4.1	TS_ player1_board_draw
4.1.1	プレイヤー1のボードの描画を行うサブルーチン
4.2	TS_ player2_board_draw
4.2.1	プレイヤー2のボードの描画を行うサブルーチン

松本吏司
-GPIO_init.s
--GPIO_init
---スタックの初期化とGPIOの初期設定を行う

-PWM_init.s
--PWM_init
---クロックソースの初期化及び動作モードの設定を行う
--clock_src_init
---クロックソースの初期化を行う

-MS_play_bgm.s
--MS_play_bgm
---bgmを再生するサブルーチン
---サブルーチン先頭で，SEと干渉しないか・タスクの実行時間は来ているかの順にタスクの実行判定を行う
---実行時にタスクの目標時刻の更新を行い，楽譜から音を取得し音を鳴らす
---楽譜をテンプレートに沿って書くことで，音楽を奏でられるように実装
--MS_play_bgm_init
---データセクションに保持しているオフセットなどを初期化する
--MS_set_bgm_target
---音楽を鳴らす前の外のループで呼び出すことで，タスクの初期実行時刻をセットする

-MS_play_SE.s
--MS_play_SE
---SEを再生するサブルーチン
---サブルーチン先頭でSEが既に鳴っている場合，音を止めるかの判定を行う
---KT_collisionの値を取得し，壁または反射板に当たったかを判定し，SEを鳴らす
--MS_play_SE_init
---データセクションに保持しているオフセットなどを初期化する

-MS_bgm_list.s
--MS_bgm_list
---再生するbgmのリストを記載したデータセクション
--MS_bgm_len_list
---再生するbgmの各音の長さのリストを記載したデータセクション

-MS_bgm_flashman.s
--MS_flashman
---奏でる各音を記載したデータセクション
---音はアメリカ式で，休符は 0 で示す
--MS_flashman_len
---奏でる各音の長さを記載したデータセクション
---末尾に 0xffffffff を置くことで，楽譜の終了を示す

-MS_bgm_fox_20th.s
-MS_bgm_title.s
-MS_bgm_saria.s
---上記同様のデータセクション

-MS_SE.s
--MS_SE
---再生するSEのリストを記載したデータセクション
--MS_SE_len
---再生するSEの各音の長さのリストを記載したデータセクション

森岡悠人
-score.s
--MY_show_score
---現在の両プレイヤーの点数を受け取ってframe_bufferに数字を横向きに書き込むサブルーチン．
---rotate.sのサブルーチンを使ってスコア表示を回転させる処理を毎回ループで呼ぶと高速で数字が回転してしまうため，これを直すためにフラグを使ってbufferを書き換えた後回転にストップをかけるのが難しかった．
--MY_buffer_ischanged_init
---buffer書き換えのフラグを初期化するシンプルなサブルーチン
-result.s
--MY_show_result
---勝敗に応じて1p側ないし2p側に「YOU WIN」と文字を流すプログラム
---勝敗が決まった時に，勝ったのが1pか2pかで,文字を流す方向を反転させる処理が難しかった．
---rotate.sの90度回転において回転回数の指定がうまくできず，2p側の表示をx軸反転とy軸反転を組み合わせて対処したところが大変だった．
--MY_show_result
---MY_show_resultのための初期化サブルーチン．
---2p勝利時，初めに「YOU WIN」を読み込んだ瞬間に反転が入るよう工夫した
-rotate.s
--MY_rotate_90
---MY_rotate_90_nというデータ領域に書き込まれた回数分frame_buffer全体を反時計回りに90度回転させるサブルーチン
---x軸で反転，y軸で反転，転地の3つのサブルーチンを作成する際に，別のswap用のframe_buffer領域を用意しておいて，そのswapを利用しながら書き換える処理が難しかった．
--MY_x_rotate_buffer
---x軸で反転させるサブルーチン
--MY_y_rotate_buffer
---y軸で反転させるサブルーチン

久保田 作成
ball.s

KT_ball_init
・初期化用サブルーチン

KT_ball_move
・ボールの座標は8bitを整数部,24bitを小数部に割り当てた固定少数形式で保存されており、
描画の処理には24bit右シフトを行うことで実現している。
・ボールの角度はあらかじめ用意した角度テーブルの値を呼び出して利用している。
・ボールの速度はサブルーチンの更新間隔を調整することで変化させており、
ボールはplayerの操作する反射板と衝突するごとに加速している。
・ボールがplayerの操作する反射板と衝突したときplayerの反射板の移動方向により、
ボールの角度が変化するようにしている。
・ボールの初期位置は初めはplayer1の位置に隣接しており、それ以降では前のラウンドで得点を
入れられなかったplayerに隣接している。
・ボールは隣接しているplayerが入力を行ったタイミングで移動を開始する。

framebuffer_ball_pos_write, framebuffer_ball_pos_clear
・ボールの位置をframe_bufferに記入、削除

ball_dir_reflect_x, ball_dir_reflect_y
・x,y軸の反射判定を行う

ball_dir_add, ball_dir_sub
・ボールの角度を加算,減算を行う

KT_ball_init_player1, KT_ball_init_player2
・次ラウンドのボールの初期位置及び初期角度指定

KT_ball_player1_pushed, KT_ball_player2_pushed
・ボールの移動フラグ更新

林 晃太郎 作成プログラム
********** display.s **********
*HK_display
**8ms 周期で matrixLED を光らせる
**print_line を使って各行で判定をすることによって簡潔化
*all_clear
**matrixLED を全て消灯
*print_line
**指定された行の matrixLED を点灯
**点灯させる場所を OR 演算でまとめて格納
*HK_fb_clear
**frame_buffer を全て 0 にする
**word 単位で書き込むことによってループするより少しだけ高速化、簡潔化
********************

********** point.s **********
*HK_add_point1
**player1 の得点を加算
**得点加算時に勝利判定 (winner 1)
*HK_add_point2
**player2 の得点を加算
**得点加算時に勝利判定 (winner 2)
*HK_reset_poin
**player1, player2 の得点, 勝者の判定をリセットする
********************

********** start.s **********
*HK_start
**スタート画面を再生する
**サブルーチンが使いやすかったため楽だった
*HK_start_init
**スタート画面の初期設定
********************

********** text.s **********
一番頑張った
*HK_slide_text
**text を一定間隔で 1 マスずつ左にずらす (改行コード (\n) でループ)
**一定時間ごとに現在地を示しているデータを 1 加算して frame_buffer を書き換える処理を読んでいるだけ
*HK_slide_text_rotate
**HK_slide_text を 180 度回転させたバージョン
**タイマーは共有. player が 2 人いるので表示が分かりやすいように
**frame_buffer に text を書き込み x, y 軸で反転させているだけ...正直適当
*HK_write_text
**再生する文字列の更新
**frame_buffer のように特定の番地のデータを書き換えて利用する
**frame_buffer と違う点は長さは基本自由で (現在 1000 程領域を確保している (変更可)) 改行コード (\n) で文字列の最後を表す (今思えば (\0) の方が良かった)
**利用する側で文字列を毎回書き換えるのは面倒なので, 文字列データの番地を受け取りこのサブルーチンで書き換えている.
**ポインタのポインタの様な使い方をしているので頭がこんがらがる
**ここでタイマーのリセットもしている
*HK_reset_text_position
**text の先頭に戻る
*HK_read_text
**text を frame_buffer に書き込み
**現在地が格納されているデータで使う先頭の文字を選択し OR 演算と 左SHIFT を使って 3 文字分取り出し, 最後に 右SHIFT して位置の調整
*get_text_data
**文字列データをレジスタに書き込み
**データを ascii コード順に並べることによりスペースから何個先の文字かで指定
**スペース (0x22) から 大文字 Z まで対応. 時間があれば小文字も追加したかった
*clean
**frame_buffer の値をすべて 0 にする
*mod
**レジスタで指定された数値の余りを返す
**自分が昔に書いたコードの流用
********************

********** write_number.s **********
*HK_write_number
**matrixLED に数値を表示 (1 桁)
**入力の 1 の位を frame_buffer に書き込み
*HK_write_numbers
**matrixLED に数値を表示 (2 桁)
**入力の 10 の位と 1 の位を frame_buffer に書き込み
**1 の位と 10 の位だけを抽出する処理が上手く行かず苦戦した結果 mod も求めるサブルーチンを作成した
*mod
**余りの計算をするだけ
**mod 演算を main 内で使うと頭がこんがらがる
*number
**数値データの配列を返す
*clean
**frame_buffer を全て 0 にする
*write
**数値データの配列を frame_buffer に書き込み
**frame_buffer のデータを 4bit シフトから OR 演算で書き込む
********************
