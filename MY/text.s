/*--------------------------------------
HK_text に書き込まれた値を流す \nでループ

HK_text: 表示される文字列(先頭にスペースを1つか2つ入れたら綺麗になる)
HK_text_delay: 文字が進んでいく間隔 (1 マス)
HK_text_start_time: 文字列が更新されてから流れ始めるまでの時間
HK_update_text_address: 変更したい文字列のアドレス

HK_slide_text:
	input: なし!
	HK_text を HK_text_delay 間隔で 1 マスずつ左に流す (改行コード(\n)でループ)
HK_write_text:
	input: HK_update_text_address に表示したい文字列データの先頭アドレスをいれる
	HK_text を HK_update_text_address に入っているアドレスの文字列に書き換える
HK_slide_text_rotate:
	input: なし!
	HK_slide_text をした後、回転させる

HK_reset_text_position:
	input: なし!
	HK_text の先頭に戻る
HK_read_text:
	input: なし!
	HK_slide_text の移動しないバージョン
--------------------------------------*/

	.include	"common.h"
	.section	.text
	.global	HK_slide_text, HK_reset_text_position, HK_read_text, HK_write_text, HK_slide_text_rotate

@ 表示される text を 1 回左にずらす
HK_slide_text:
	push	{r0-r12, r14}

	ldr	r0, =TIMER_BASE
	ldr	r1, [r0, #CLO]
	ldr	r2, =timer
	ldr	r3, [r2]
	cmp	r1, r3
	ble	skip

	ldr	r0, =HK_text_delay
	ldr	r1, [r0]
	add	r1, r3
	str	r1, [r2]

	ldr	r0, =text_position
	ldr	r1, [r0]
	add	r1, r1, #1
	str	r1, [r0]

	bl	HK_read_text
	skip:
	pop	{r0-r12, r15}

@ 表示される text を 1 回左にずらすして回転
HK_slide_text_rotate:
	push	{r0-r12, r14}

	ldr	r0, =TIMER_BASE
	ldr	r1, [r0, #CLO]
	ldr	r2, =timer
	ldr	r3, [r2]
	cmp	r1, r3
	ble	skipRot

	ldr	r0, =HK_text_delay
	ldr	r1, [r0]
	add	r1, r3
	str	r1, [r2]

	ldr	r0, =text_position
	ldr	r1, [r0]
	add	r1, r1, #1
	str	r1, [r0]

	bl	HK_read_text
	bl	MY_x_rotate_buffer
	bl	MY_y_rotate_buffer

skipRot:
	pop	{r0-r12, r15}

@ frame_buffer に書き込み
HK_write_text:
	push	{r0-r12, r14}

	ldr	r0, =HK_text
	ldr	r1, =HK_update_text_address
	ldr	r1, [r1]
	loop:
		ldrb	r2, [r1], #1
		strb	r2, [r0], #1
		cmp	r2, #0x0a
		bleq	loop_end
		b	loop
	loop_end:

	ldr	r0, =TIMER_BASE
	ldr	r0, [r0, #CLO]
	ldr	r2, =HK_text_start_time
	ldr	r2, [r2]
	add	r0, r0, r2
	ldr	r1, =timer
	str	r0, [r1]

	bl	HK_reset_text_position
	
	pop	{r0-r12, r15}

@ text の位置を初期値に戻す
HK_reset_text_position:
	push	{r0-r12, r14}

	ldr	r0, =text_position
	ldr	r1, =0
	str	r1, [r0]

	bl	HK_read_text

	pop	{r0-r12, r15}

@ frame_buffer に text_position だけ左に移動した text を書き込む
HK_read_text:
	push	{r0-r12, r14}

	bl	clean
	@ (p / 5) 何文字目を使うか
	ldr	r0, =text_position
	ldr	r1, [r0]
	ldr	r2, =5
	@ r0 = r1 % r2
	bl	mod
	@ r2 = positon / 5
	udiv	r2, r1, r2
	@ r4 = positoin % 5
	mov	r4, r0

	@ なんの文字を使うかを r1 に書き込む
	ldr	r3, =HK_text
	add	r3, r3, r2
	ldrb	r1, [r3], #1
	/* 
	改行文字が来たらループ
	if (r1 == '\n') {
		r3 = HK_text;
		ldrb	r1, [r3], #1
		bl	HK_rest_text_positoin
	}
	*/
	cmp	r1, #0x0a
	ldreq	r3, =HK_text
	ldreqb	r1, [r3], #1
	bleq	HK_reset_text_position

	bl	get_text_data
	mov	r5, r0

	ldrb	r1, [r3], #1
	@ 改行文字が来たらループ
	cmp	r1, #0x0a
	ldreq	r3, =HK_text
	ldreqb	r1, [r3], #1

	bl	get_text_data
	mov	r6, r0

	ldrb	r1, [r3], #1
	@ 改行文字が来たらループ
	cmp	r1, #0x0a
	ldreq	r3, =HK_text
	ldreqb	r1, [r3], #1

	bl	get_text_data
	mov	r7, r0

	@ frame_buffer に書き込み
	@ 3 文字分、計算して複数回右シフト
	@ positoin % 5(文字幅) だけ右にずらす
	ldr	r10, =8
	ldr	r0, =frame_buffer
	ldr	r8, =5
	sub	r4, r8, r4
	loop0:
		ldrb	r1, [r5], #1
		lsl	r1, r1, #10
		ldrb	r2, [r6], #1
		lsl	r2, r2, #5
		ldrb	r3, [r7], #1

		orr	r1, r1, r2
		orr	r1, r1, r3
		lsr	r1, r1, r4
		strb	r1, [r0], #1
		subs r10, r10, #1
		bne loop0

	pop	{r0-r12, r15}

@ r1 に入った 文字データ ('A') に対してマトリックス LED の配列アドレスを r0 に格納して返す
get_text_data:
	push	{r1-r12, r14}

	@ space のとき
	cmp	r1, #0x20
	ldreq	r0, =SPACE
	popeq	{r1-r12, r15}

	@ 'A' から何文字先か
	ldr	r2, ='A'
	sub	r2, r1, r2


	@ 1 文字 8 行
	ldr	r3, =A
	ldr	r10, =8
	mul	r4, r2, r10
	add	r0, r3, r4

	pop	{r1-r12, r15}

@ frame_buffer の値を全て 0 にする
clean:
	push	{r0-r12, r14}
	ldr	r2, =frame_buffer
	ldr	r0, =8
	clean0:
		ldr	r1, =0
		strb	r1, [r2], #1
		subs	r0, r0, #1
		bne	clean0
	pop	{r0-r12, r15}

@ r1 % r2 = ? ... return r0
mod:
	push	{r1-r12, r14}
	
	udiv	r3, r1, r2
	mul	r4, r2, r3
	sub	r0, r1, r4
	
	pop	{r1-r12, r15}


@ 文字列データ
	.section	.data
SPACE:	.byte	0, 0, 0, 0, 0, 0, 0, 0

Exclamation: .byte	0, 0x6, 0x6, 0x6, 0x6, 0x0, 0x6, 0
Quotation: .byte	0, 0x5, 0x5, 0xa, 0x0, 0x0, 0x0, 0
Number_Sign: .byte	0, 0x00, 0x0a, 0x1f, 0x0a, 0x1f, 0x0a, 0
Dollar: .byte	0x04, 0x0e, 0x15, 0x0c, 0x06, 0x15, 0x0e, 0x04
Percent: .byte	0, 0x00, 0x15, 0x16, 0x04, 0x0b, 0x13, 0
/*
Ampersand: .byte	0, 0x6, 0x9, 0x9, 0xf, 0x9, 0x9, 0
Apostrophe: .byte	0, 0x6, 0x9, 0x9, 0xf, 0x9, 0x9, 0
Left_Parenthesis: .byte	0, 0x6, 0x9, 0x9, 0xf, 0x9, 0x9, 0
Right_Parenthesis: .byte	0, 0x6, 0x9, 0x9, 0xf, 0x9, 0x9, 0
Asterisk: .byte	0, 0x6, 0x9, 0x9, 0xf, 0x9, 0x9, 0
Plus: .byte	0, 0x6, 0x9, 0x9, 0xf, 0x9, 0x9, 0
Plus: .byte	0, 0x6, 0x9, 0x9, 0xf, 0x9, 0x9, 0
Hyphen: .byte	0, 0x6, 0x9, 0x9, 0xf, 0x9, 0x9, 0
Full_Stop: .byte	0, 0x6, 0x9, 0x9, 0xf, 0x9, 0x9, 0
Solidus: .byte	0, 0x6, 0x9, 0x9, 0xf, 0x9, 0x9, 0
Colon: .byte	0, 0x6, 0x9, 0x9, 0xf, 0x9, 0x9, 0
Semicolon: .byte	0, 0x6, 0x9, 0x9, 0xf, 0x9, 0x9, 0
Less: .byte	0, 0x6, 0x9, 0x9, 0xf, 0x9, 0x9, 0
Equals: .byte	0, 0x6, 0x9, 0x9, 0xf, 0x9, 0x9, 0
Greater: .byte	0, 0x6, 0x9, 0x9, 0xf, 0x9, 0x9, 0
*/

zero:	.byte	0x0, 0xe, 0xa, 0xa, 0xa, 0xe, 0x0, 0x0
one:	.byte	0x0, 0x4, 0xc, 0x4, 0x4, 0xe, 0x0, 0x0
two:	.byte	0x0, 0xe, 0x2, 0xe, 0x8, 0xe, 0x0, 0x0
three:	.byte	0x0, 0xe, 0x2, 0xe, 0x2, 0xe, 0x0, 0x0
four:	.byte	0x0, 0xa, 0xa, 0xe, 0x2, 0x2, 0x0, 0x0
five:	.byte	0x0, 0xe, 0x8, 0xe, 0x2, 0xe, 0x0, 0x0
six:	.byte	0x0, 0xe, 0x8, 0xe, 0xa, 0xe, 0x0, 0x0
seven:	.byte	0x0, 0xe, 0xa, 0x2, 0x2, 0x2, 0x0, 0x0
eight:	.byte	0x0, 0xe, 0xa, 0xe, 0xa, 0xe, 0x0, 0x0
nine:	.byte	0x0, 0xe, 0xa, 0xe, 0x2, 0xe, 0x0, 0x0

Question: .byte	0, 0x0e, 0x11, 0x02, 0x04, 0x04, 0x00, 0x04
At: .byte	0, 0x0e, 0x11, 0x15, 0x1b, 0x1f, 0x0d, 0

A:	.byte	0, 0x6, 0x9, 0x9, 0xf, 0x9, 0x9, 0
B:	.byte	0, 0xe, 0x9, 0xe, 0x9, 0x9, 0xe, 0
C:	.byte	0, 0x6, 0x9, 0x8, 0x8, 0x9, 0x6, 0
D:	.byte	0, 0xe, 0x9, 0x9, 0x9, 0x9, 0xe, 0
E:	.byte	0, 0xf, 0x8, 0xf, 0x8, 0x8, 0xf, 0
F:	.byte	0, 0xf, 0x8, 0xf, 0x8, 0x8, 0x8, 0
G:	.byte	0, 0x6, 0x9, 0x8, 0xb, 0x9, 0x7, 0
H:	.byte	0, 0x9, 0x9, 0xf, 0x9, 0x9, 0x9, 0
I:	.byte	0, 0x7, 0x2, 0x2, 0x2, 0x2, 0x7, 0
J:	.byte	0, 0x7, 0x2, 0x2, 0x2, 0xa, 0x4, 0
K:	.byte	0, 0x9, 0xa, 0xc, 0xc, 0xa, 0x9, 0
L:	.byte	0, 0x8, 0x8, 0x8, 0x8, 0x8, 0xf, 0
M:	.byte	0, 0x11, 0x1b, 0x1b, 0x15, 0x11, 0x11, 0
N:	.byte	0, 0x9, 0xd, 0xd, 0xb, 0xb, 0x9, 0
O:	.byte	0, 0x6, 0x9, 0x9, 0x9, 0x9, 0x6, 0
P:	.byte	0, 0xe, 0x9, 0xe, 0x8, 0x8, 0x8, 0
@Q:	.byte	0, 0x6, 0x9, 0x9, 0xd, 0xa, 0x5, 0
Q:	.byte	0, 0x0e, 0x11, 0x11, 0x15, 0x12, 0x0d, 0
@Q:	.byte	0, 0x0e, 0x11, 0x11, 0x15, 0x1a, 0x0d, 0
R:	.byte	0, 0xe, 0x9, 0xe, 0xc, 0xa, 0x9, 0
S:	.byte	0, 0x6, 0x9, 0x4, 0x2, 0x9, 0x6, 0
T:	.byte	0, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x04, 0
U:	.byte	0, 0x9, 0x9, 0x9, 0x9, 0x9, 0x6, 0
V:	.byte	0, 0x11, 0x11, 0x11, 0x0a, 0x0e, 0x04, 0
W:	.byte	0, 0x11, 0x11, 0x15, 0x1b, 0x1b, 0x11, 0
X:	.byte	0, 0x9, 0x9, 0x6, 0x6, 0x9, 0x9, 0
Y:	.byte	0, 0x11, 0x11, 0x0a, 0x04, 0x04, 0x04, 0
Z:	.byte	0, 0xf, 0x1, 0x2, 0x4, 0x8, 0xf, 0




text_position:	.word	0
timer:	.word	0

	.global	HK_text, HK_text_delay, HK_text_start_time, HK_update_text_address
HK_text_delay:	.word	100 * 1000
HK_text_start_time:	.word	1 * 1000 * 1000
HK_update_text_address: .word	(. + 4)
HK_text:	.ascii	" HELLO WORLD\n"
					.space	1000



